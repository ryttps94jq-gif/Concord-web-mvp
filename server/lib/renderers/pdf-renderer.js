/**
 * PDF Renderer — shared pdfkit wrapper that consumes the section format
 * from _lensExportPDFMarkup. Pure Node, zero native dependencies.
 *
 * Section types: title, subtitle, meta, heading, table, list, text, note
 */

let PDFDocument = null;

async function ensurePDFKit() {
  if (PDFDocument) return;
  try {
    const mod = await import("pdfkit");
    PDFDocument = mod.default || mod;
  } catch {
    throw new Error("pdfkit not installed — run: npm install pdfkit");
  }
}

/**
 * Render a table into the PDF document.
 */
function renderTable(doc, headers, rows) {
  if (!headers?.length) return;

  const pageWidth = doc.page.width - doc.page.margins.left - doc.page.margins.right;
  const colWidth = Math.floor(pageWidth / headers.length);

  // Header row
  doc.font("Helvetica-Bold").fontSize(9);
  const headerY = doc.y;
  headers.forEach((h, i) => {
    doc.text(String(h), doc.page.margins.left + i * colWidth, headerY, {
      width: colWidth - 4,
      continued: false,
    });
  });
  doc.moveDown(0.3);

  // Separator line
  const lineY = doc.y;
  doc.moveTo(doc.page.margins.left, lineY)
    .lineTo(doc.page.margins.left + pageWidth, lineY)
    .lineWidth(0.5)
    .stroke();
  doc.moveDown(0.3);

  // Data rows
  doc.font("Helvetica").fontSize(9);
  for (const row of (rows || []).slice(0, 200)) {
    const rowY = doc.y;
    if (rowY > doc.page.height - doc.page.margins.bottom - 30) {
      doc.addPage();
    }
    const startY = doc.y;
    (row || []).forEach((cell, i) => {
      doc.text(String(cell ?? ""), doc.page.margins.left + i * colWidth, startY, {
        width: colWidth - 4,
        continued: false,
      });
    });
    doc.moveDown(0.2);
  }
}

/**
 * Render structured sections into a PDF buffer.
 *
 * @param {Array} sections - Array of section objects from _lensExportPDFMarkup
 * @param {Object} pageInfo - { title, domain, generatedAt }
 * @returns {Promise<Buffer>} PDF file buffer
 */
export async function renderPDF(sections, pageInfo) {
  await ensurePDFKit();

  return new Promise((resolve, reject) => {
    const doc = new PDFDocument({ margin: 50, size: "LETTER" });
    const chunks = [];
    doc.on("data", (c) => chunks.push(c));
    doc.on("end", () => resolve(Buffer.concat(chunks)));
    doc.on("error", reject);

    // Header
    doc.font("Helvetica-Bold").fontSize(20).text(pageInfo.title || "Untitled", { align: "center" });
    doc.font("Helvetica").fontSize(10).text(
      `${pageInfo.domain || "Concord"} — Generated ${pageInfo.generatedAt || new Date().toISOString()}`,
      { align: "center" }
    );
    doc.moveDown(1.5);

    for (const section of sections) {
      // Page break check
      if (doc.y > doc.page.height - doc.page.margins.bottom - 60) {
        doc.addPage();
      }

      switch (section.type) {
        case "title":
          doc.font("Helvetica-Bold").fontSize(18).text(section.text);
          doc.moveDown(0.5);
          break;

        case "subtitle":
          doc.font("Helvetica").fontSize(12).fillColor("#555555").text(section.text);
          doc.fillColor("#000000");
          doc.moveDown(0.5);
          break;

        case "meta":
          if (section.fields?.length) {
            for (const f of section.fields) {
              doc.font("Helvetica-Bold").fontSize(9).text(`${f.label}: `, { continued: true });
              doc.font("Helvetica").text(String(f.value ?? ""));
            }
          }
          doc.moveDown(0.5);
          break;

        case "heading":
          doc.font("Helvetica-Bold").fontSize(14).text(section.text);
          doc.moveDown(0.5);
          break;

        case "table":
          renderTable(doc, section.headers, section.rows);
          break;

        case "list":
          doc.font("Helvetica").fontSize(10);
          for (const item of (section.items || []).slice(0, 200)) {
            doc.text(`\u2022 ${item}`);
          }
          break;

        case "text":
          doc.font("Helvetica").fontSize(10).text(section.text);
          break;

        case "note":
          doc.font("Helvetica-Oblique").fontSize(9).fillColor("#666666").text(section.text);
          doc.fillColor("#000000");
          break;

        default:
          if (section.text) doc.font("Helvetica").fontSize(10).text(section.text);
          break;
      }
      doc.moveDown(0.8);
    }

    // Footer
    doc.font("Helvetica").fontSize(8).fillColor("#999999")
      .text("Generated by Concord Cognitive Engine", doc.page.margins.left, doc.page.height - 40, { align: "center" });

    doc.end();
  });
}
